#!/usr/bin/env roseus

(load "package://jsk_perception/euslisp/detection_utils.l")
(load "package://euslisp/jskeus/irteus/kalmanlib.l")


(defvar *detection-topic* "/openni/rgb/ObjectDetection")

(defun calc-kalman-filter (target-obj kfp kfr0 kfr1 kfr2)
  (let* ((coords (send target-obj :copy-worldcoords))
         (rot (send coords :rot))
         (pose (ros::coords->tf-pose coords))
         (x (* 1000 (send pose :position :x)))
         (y (* 1000 (send pose :position :y)))
         (z (* 1000 (send pose :position :z)))
         (p (float-vector x y z))
         (p^ (send kfp :proc p))
         (np (norm (float-vector (abs (- x (elt p^ 0))) (abs (- y (elt p^ 1))) (abs (- z (elt p^ 2))))))

         (rot0 (float-vector (aref rot 0 0) (aref rot 0 1) (aref rot 0 2)))
         (rot1 (float-vector (aref rot 1 0) (aref rot 1 1) (aref rot 1 2)))
         (rot2 (float-vector (aref rot 2 0) (aref rot 2 1) (aref rot 2 2)))
         (rot0^ (send kfr0 :proc rot0))
         (rot1^ (send kfr1 :proc rot1))
         (rot2^ (send kfr2 :proc rot2))
         (nr (norm (float-vector (- (aref rot 0 0) (elt rot0^ 0)) (- (aref rot 0 1) (elt rot0^ 1)) (- (aref rot 0 2) (elt rot0^ 2))
                                 (- (aref rot 1 0) (elt rot1^ 0)) (- (aref rot 1 1) (elt rot1^ 1)) (- (aref rot 1 2) (elt rot1^ 2))
                                 (- (aref rot 2 0) (elt rot2^ 0)) (- (aref rot 2 1) (elt rot2^ 1)) (- (aref rot 2 2) (elt rot2^ 2)))))
         (filter-obj (make-cube 60 60 60))
         (rot-mat (make-array (list 3 3)))
         )
    (ros::ros-info "error:~A" (send kfp :error))
    (ros::ros-info "coords:~A  pose:~A position:~A" coords pose (send pose :position))
    (ros::ros-info " raw:(~A ~A ~A)" x y z)
    (ros::ros-info "  kf:(~A ~A ~A)" (elt p^ 0) (elt p^ 1) (elt p^ 2))
    (ros::ros-info "diff:(~A ~A ~A)" (abs (- x (elt p^ 0))) (abs (- y (elt p^ 1))) (abs (- z (elt p^ 2))))
    (ros::ros-info "norm pose:~A" np)
    (ros::publish "/norm/pose" (instance std_msgs::Float32 :init :data np))

    (ros::ros-info "rot0:~A rot1:~A rot2:~A" rot0 rot1 rot2)
    (ros::ros-info "rot0^:~A rot1^:~A rot2^:~A" rot0^ rot1^ rot2^)
    (ros::ros-info "norm rot:~A" nr)
    (ros::publish "/norm/rot" (instance std_msgs::Float32 :init :data nr))

    (send filter-obj :reset-coords)
    (setf (get filter-obj :type) (format t "filtered ~A" (get filter-obj :type)))
    (send filter-obj :name "filtered")
    (send filter-obj :stamp (send target-obj :stamp))
    (send filter-obj :frame_id (send target-obj :frame_id))
    (setf (aref rot-mat 0 0) (elt rot0^ 0))
    (setf (aref rot-mat 0 1) (elt rot0^ 1))
    (setf (aref rot-mat 0 2) (elt rot0^ 2))
    (setf (aref rot-mat 1 0) (elt rot1^ 0))
    (setf (aref rot-mat 1 1) (elt rot1^ 1))
    (setf (aref rot-mat 1 2) (elt rot1^ 2))
    (setf (aref rot-mat 2 0) (elt rot2^ 0))
    (setf (aref rot-mat 2 1) (elt rot2^ 1))
    (setf (aref rot-mat 2 2) (elt rot2^ 2))
    (send filter-obj :newcoords rot-mat p^)
    (ros::ros-info "pos : ~A" (send filter-obj :pos))
    (ros::ros-info "rot : ~A" (send filter-obj :rot))
    (ros::ros-info "filter name:~A stamp:~A frame_id:~A world-coords:~A" (send filter-obj :name) (send filter-obj :stamp) (send filter-obj :frame_id) (send filter-obj :copy-worldcoords))
    filter-obj
    ))

(defun calc-distribution (x sigma xa)
  (let* ((x-xa (v- x xa))
         (tt (* -0.5 (v. x-xa (transform (inverse-matrix sigma) x-xa))))
         (det (abs (- (* (aref sigma 0 0) (aref sigma 1 1)) (* (aref sigma 0 1) (aref sigma 1 0)))))
         (p (/ (exp tt) (* (* 2 pi) (expt det 0.5))))
         )
    ;; (ros::ros-info "inverse:~A exptt:~A exptdet:~A x-xa:~A tt:~A det:~A p:~A" (inverse-matrix sigma) (exp tt) (expt det 0.5)  x-xa tt det p)
    ;; (ros::ros-info "x-xa:~A tt:~A det:~A p:~A" x-xa tt det p)
    p
    )
  )

(defun calc-probability (x sigma xa)
  (let ((N 10)
        (S 0)
        (tmpx 0)
        (tmpy 0)
        )
    (dotimes (i N nil)
      (setf tmpx (- (+ (elt x 0) (/ (* 1.0 i) N)) 0.5))
      (dotimes (j N nil)
        (setf tmpy (- (+ (elt x 1) (/ (* 1.0 j) N)) 0.5))
        (setf S (+ S (/ (/ (calc-distribution (float-vector tmpx tmpy) sigma xa) (* N 1.0)) N)))
;;        (ros::ros-info "x:~A y:~A calcdist:~A" tmpx tmpy (calc-distribution (float-vector tmpx tmpy) sigma xa))
       )
      )
    S
    )
  )

(defun publish-2Dpointcloud (kfp)
  (let* ((P (cdr (assoc 'p_k (send kfp :slots))))
         (sigma (make-matrix 2 2))
         (xa (float-vector (elt (cdr (assoc 'x_k-1 (send kfp :slots))) 0) (elt (cdr (assoc 'x_k-1 (send kfp :slots))) 1)))
         )
    (ros::ros-info "P:~A xa:~A" P xa)
    (setf (aref sigma 0 0) (aref P 0 0))
    (setf (aref sigma 0 1) (aref P 0 1))
    (setf (aref sigma 1 0) (aref P 1 0))
    (setf (aref sigma 1 1) (aref P 1 1))
    (ros::ros-info "sigma: ~A ~A ~A ~A" (aref sigma 0 0) (aref sigma 0 1) (aref sigma 1 0) (aref sigma 1 1))
    (dotimes (y 3 nil)
      (let ((a nil))
        (dotimes (x 3 nil)
          (let ((xy (float-vector (+ (elt xa 0) (- x 1)) (+ (elt xa 1) (- y 1)))))
            (setq a (append a (list (calc-probability xy sigma xa))))
            )
          )
        (ros::ros-info "~A ~A ~A" (elt a 0) (elt a 1) (elt a 2))
        )
      )
    )
  )


(defun pub-cb (target-obj marker-life force kfp kfr0 kfr1 kfr2 msg)
  (let ((filter-obj))
    (detection-interface-objectdetection force target-obj msg)
    (cond
      ((send target-obj :stamp);;for tf error
       (setq filter-obj (calc-kalman-filter target-obj kfp kfr0 kfr1 kfr2))
       (publish-marker target-obj marker-life )
       (publish-marker filter-obj marker-life :publish-name "/filtered")
       (publish-2Dpointcloud kfp)
       )
      (t
       nil)
      )
    )
  )
(defun only-perception (&key (timeout 10) ((:type atype) nil) (tf-force nil)
                             (diff-position 10.0)
                             (diff-rotation 1) ;; radian
                             (single nil) (speak nil)
                             (publish-objectdetection-marker t)
                             (marker-life 30)
                             (detection-topic *detection-topic*)
                             ((:target-object target-obj) (make-cube 60 60 60))
                        )
  (let ((tgt-cds (send target-obj :copy-worldcoords))
;;        (kfp (instance kalman-filter :init :state-dim 3 :measure-dim 3 :r-variance 0.001))
        (kfp (instance kalman-filter :init :state-dim 6 :measure-dim 3 :r-variance 1))
        (kfr0 (instance kalman-filter :init :state-dim 3 :measure-dim 3 :r-variance 0.001))
        (kfr1 (instance kalman-filter :init :state-dim 3 :measure-dim 3 :r-variance 0.001))
        (kfr2 (instance kalman-filter :init :state-dim 3 :measure-dim 3 :r-variance 0.001))
        )
    (send kfp :A #2f((1 0 0 1 0 0) (0 1 0 0 1 0) (0 0 1 0 0 1) (0 0 0 1 0 0) (0 0 0 0 1 0) (0 0 0 0 0 1)))
    (send target-obj :reset-coords)
    (setf (get target-obj :type) atype)
    (ros::subscribe detection-topic
                  posedetection_msgs::ObjectDetection
                  #'pub-cb target-obj marker-life tf-force kfp kfr0 kfr1 kfr2))
    (ros::rate 10)
    (ros::advertise "/object_detection_marker_array" visualization_msgs::MarkerArray 5)
    (ros::advertise "/filtered" visualization_msgs::MarkerArray 5)
    (ros::advertise "/norm/pose" std_msgs::Float32 1)
    (ros::advertise "/norm/rot" std_msgs::Float32 1)
    (ros::spin)
)

(only-perception)



